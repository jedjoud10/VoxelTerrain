#pragma kernel CSCull

#define UNITY_INDIRECT_DRAW_ARGS IndirectDrawIndexedArgs
#include "UnityIndirect.cginc"
#include "Packages/com.jedjoud.voxelterrain/Runtime/Compute/Props.cginc"

StructuredBuffer<uint4> perm_buffer;
RWStructuredBuffer<uint> indirection_buffer;
StructuredBuffer<uint> perm_props_in_use_bitset_buffer;
StructuredBuffer<int> perm_buffer_counts_buffer;
StructuredBuffer<int> perm_buffer_offsets_buffer;
StructuredBuffer<uint> perm_buffer_type_indices_buffer;

RWStructuredBuffer<uint> visible_props_counters_buffer;

int max_combined_perm_props;
float3 camera_position;
float3 camera_forward;

[numthreads(32, 1, 1)]
void CSCull(uint3 id : SV_DispatchThreadID) {
	int block = perm_props_in_use_bitset_buffer[id.x];

	for (int i = 0; i < 32; i++) {
		int local = i;
		int index = id.x * 32 + i;

		int type_index_block = index / 4;
		int type_index_local = index % 4;
		int type = (perm_buffer_type_indices_buffer[type_index_block] >> (type_index_local * 8)) & 0xFF;
		
		if (index >= max_combined_perm_props) {
			return;
		}

		bool valid = ((block >> local) & 1) == 1;
		bool visible = false;

		float4 position_scale;
		float4 rotation;

		uint4 prop = perm_buffer[index];
		position_scale = UnpackPositionAndScale(prop.xy);
		rotation = UnpackRotation(prop.zw);

		visible = true;
		//visible = dot(normalize(position_scale.xyz - camera_position), camera_forward) > 0.0;
		
		if (valid && visible) {
			uint dst_index;
			InterlockedAdd(visible_props_counters_buffer[type], 1u, dst_index);
			dst_index += (uint)perm_buffer_offsets_buffer[type];
			indirection_buffer[dst_index] = index;
		}
	}
}