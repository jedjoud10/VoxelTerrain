#pragma kernel CSCull

#include "Packages/com.jedjoud.voxelterrain/Runtime/Compute/Props.cginc"

StructuredBuffer<uint4> perm_buffer;
StructuredBuffer<uint> perm_props_in_use_bitset_buffer;
StructuredBuffer<int> perm_buffer_counts_buffer;
StructuredBuffer<int> perm_buffer_offsets_buffer;

RWStructuredBuffer<uint> instanced_indirection_buffer;
RWStructuredBuffer<uint> impostor_indirection_buffer;
RWStructuredBuffer<uint> visibility_counters_buffer;

#define MAX_PROP_TYPE_COUNT 32

int max_combined_perm_props;
int types;

float4 camera_frustum_planes[6];
float4 culling_spheres[MAX_PROP_TYPE_COUNT];
float max_distances[MAX_PROP_TYPE_COUNT];
float impostor_distance_percentage[MAX_PROP_TYPE_COUNT];

float3 camera_position;

float4x4 camera_projection_matrix;
float4x4 camera_view_matrix;
float camera_near;
float camera_far;

Texture2D occlusion_depth_texture;
int occlusion_width;
int occlusion_height;

float linearizeDepth(float depth, float near, float far) {
    return (2.0 * near) / (far + near - depth * (far - near));
}

[numthreads(64, 1, 1)]
void CSCull(uint3 id : SV_DispatchThreadID) {
	int block = perm_props_in_use_bitset_buffer[id.x];

	if (block == 0) {
		return;
	}

	for (int i = 0; i < 32; i++) {
		int local = i;
		int index = id.x * 32 + i;

		int type = -1;
		for (int j = 0; j < types; j++) {
			if (index >= perm_buffer_offsets_buffer[j]) {
				type = j;
			} else {
				break;
			}
		}

		if (type == -1) {
			continue;
		}
		
		if (index >= max_combined_perm_props) {
			return;
		}

		bool valid = ((block >> local) & 1) == 1;

		uint4 prop = perm_buffer[index];
		float4 position_scale = UnpackPositionAndScale(prop.xy);
		float3 position = position_scale.xyz;
		float scale = position_scale.w;

		float3 culling_sphere_position = culling_spheres[type].xyz + position;
		float culling_sphere_radius = culling_spheres[type].w * scale;

		bool visible_in_frustum = true;
		for (int f = 0; f < 6; f++) {
			float3 plane_normal = camera_frustum_planes[f].xyz;
			float plane_distance = camera_frustum_planes[f].w;

			if ((dot(plane_normal, culling_sphere_position) + plane_distance) < -culling_sphere_radius) {
				visible_in_frustum = false;
				break;
			}
		}

		bool occluded = true;
		float4 view_position = mul(camera_view_matrix, float4(culling_sphere_position, 1.0));
		float4 clip_position = mul(camera_projection_matrix, view_position);
		clip_position /= clip_position.w;
		float4 edge_position = mul(camera_projection_matrix,float4(culling_spheres[type].xyz + float3(culling_sphere_radius, 0, 0), 0));
		float clip_radius = distance(edge_position, clip_position) * 0.5;
		//float clip_radius = 0.001;
		float2 min_uv = saturate(clip_position.xy * 0.5 + 0.5 - clip_radius);
		float2 max_uv = saturate(clip_position.xy * 0.5 + 0.5 + clip_radius);

		float nearest_clip_space_z_val = saturate(linearizeDepth(clip_position.z, camera_near, camera_far));
	    
        int2 min_pixel = int2(min_uv * float2(occlusion_width - 1, occlusion_height - 1));
        int2 max_pixel = int2(max_uv * float2(occlusion_width - 1, occlusion_height - 1));

        for (int y = min_pixel.y; y <= max_pixel.y; y += 1) {
            for (int x = min_pixel.x; x <= max_pixel.x; x += 1) {
				float rasterized_depth = occlusion_depth_texture.Load(float3(x, y, 0)).x; 

				if ((rasterized_depth + 0.001) > nearest_clip_space_z_val ) {
					occluded = false;
                    break;
                }
            }
        }


		float dist = distance(position, camera_position);
		float max_dist = max_distances[type];
		float max_instance_dist = max_dist * impostor_distance_percentage[type];
		float max_impostor_dist = max_dist;
		
		if (valid && visible_in_frustum && !occluded) {
			uint dst_index_offset = (uint)perm_buffer_offsets_buffer[type];
			uint local_dst_index;

			if (dist < max_instance_dist) {
				InterlockedAdd(visibility_counters_buffer[type * 2], 1u, local_dst_index);
				instanced_indirection_buffer[local_dst_index + dst_index_offset] = index;
			} else if (dist < max_impostor_dist) {
				InterlockedAdd(visibility_counters_buffer[type * 2 + 1], 1u, local_dst_index);
				impostor_indirection_buffer[local_dst_index + dst_index_offset] = index;
			}
		}
	}
}