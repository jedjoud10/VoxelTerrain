#pragma kernel CSVertex
#pragma kernel CSQuad

#define UNITY_INDIRECT_DRAW_ARGS IndirectDrawIndexedArgs
#include "UnityIndirect.cginc"

RWTexture3D<uint> voxels;
#include "Packages/com.jedjoud.voxelterrain/Runtime/Compute/Fetcher.cginc"

RWTexture3D<uint> vertexIds;

bool blocky;
bool materialId;
int size;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float3> colors;
RWStructuredBuffer<int> indices;

RWStructuredBuffer<uint> atomicCounters;

RWStructuredBuffer<UNITY_INDIRECT_DRAW_ARGS> cmdBuffer;

static uint3 edgePositions0[12] = {
    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
};

static uint3 edgePositions1[12] = {
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 0),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
    uint3(0, 0, 1),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
};

static uint3 test[3] = {
    uint3(1, 0, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 1),
};


static uint3 offsets[12] = {
    uint3(0, 0, 0),
    uint3(0, 1, 0),
    uint3(0, 1, 1),
    uint3(0, 0, 1),

    uint3(0, 0, 0),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 0, 0),

    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0)
};

// https://www.ronja-tutorials.com/post/047-invlerp_remap/
float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

float3 normalMaxx(uint3 id) {
    float base = fetch(id);
    float x = fetch(id + uint3(1, 0, 0));
    float y = fetch(id + uint3(0, 1, 0));
    float z = fetch(id + uint3(0, 0, 1));
    return normalize(float3(base-x, base-y, base-z));
}

[numthreads(8, 8, 8)]
void CSVertex(uint3 id : SV_DispatchThreadID) {
    if (any(id >= (uint)size)) {
        return;
    }

    int count = 0;
    float3 sum = float3(0, 0, 0);
    float3 normalSum = float3(0, 0, 0);
    float3 colorSum = float3(0,0,0);

    for (int i = 0; i < 12; i++) {
        uint3 first = edgePositions0[i];
        uint3 second = edgePositions1[i];
        float firstDensity = fetch(id + first);
        float secondDensity = fetch(id + second);
        float3 firstColor = fetchMatId(id + first);
        float3 secondColor = fetchMatId(id + second);

        if (firstDensity < 0.0 ^ secondDensity < 0.0) {
            count++;

            if (blocky) {
                sum = 0.5;
                normalSum = normalMaxx(id);
                colorSum += lerp(firstColor, secondColor, 0.5);
                break;
            } else {
                float unlerped = invLerp(firstDensity, secondDensity, 0.0);
                sum += lerp(float3(first), float3(second), unlerped);
                normalSum += lerp(normalMaxx(id + first), normalMaxx(id + second), unlerped);
                colorSum += lerp(firstColor, secondColor, unlerped);
            }
        }
    }

    if (count > 0) {
        uint oldValue = 0;
        InterlockedAdd(atomicCounters[0], 1, oldValue); 
        vertices[oldValue] = float3(id) + sum/float(count);
        //normals[oldValue] = 1.0;
        normals[oldValue] = length(normalSum) < 0.1 ? 1.0 : normalize(-normalSum);
        colors[oldValue] = materialId ? (colorSum / float(count)) : 1.0;
        vertexIds[id] = oldValue;   
    }
}

[numthreads(8, 8, 8)]
void CSQuad(uint3 id : SV_DispatchThreadID) {
    if (any(id == (uint)(size-1)) || any(id <= 2)) {
        return;
    }

    for (int i = 0; i < 3; i++) {
        float firstDensity = fetch(id);
        float secondDensity = fetch(id + test[i]);
        bool flip = firstDensity < 0.0;

        if (firstDensity < 0.0 ^ secondDensity < 0.0) {
            int check[4] = { 0, 0, 0, 0 };

            bool valid = true;
            for (int j = 0; j < 4; j++) {
                check[j] = vertexIds[id + test[i] + offsets[j + i * 4] - 1];
            
                if (check[j] <= 0) {
                    valid = false;
                }
            }

            if (valid) {
                uint oldValue = 0;
                InterlockedAdd(atomicCounters[1], 6, oldValue); 
                
                indices[oldValue + (flip ? 0 : 2)] = check[0];
                indices[oldValue + 1] = check[1];
                indices[oldValue + (flip ? 2 : 0)] = check[2];
                
                indices[oldValue + (flip ? 4 : 3)] = check[2];
                indices[oldValue + 5] = check[3];
                indices[oldValue + (flip ? 3 : 4)] = check[0];
                
    
                InterlockedAdd(cmdBuffer[0].indexCountPerInstance, 6); 
            }
        }
    }
}