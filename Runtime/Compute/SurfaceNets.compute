#pragma kernel CSVertex
#pragma kernel CSQuad
#pragma warning (disable : 4714)

#define UNITY_INDIRECT_DRAW_ARGS IndirectDrawIndexedArgs
#include "UnityIndirect.cginc"

RWTexture3D<uint> voxels;

int3 permutation_seed = int3(684, 2325, 31);
int3 modulo_seed = int3(423, 4543, -23423);

#include "Packages/com.jedjoud.voxelterrain/Runtime/Compute/Voxel.cginc"
#include "Packages/com.jedjoud.voxelterrain/Runtime/Compute/Noises/common.cginc"

Voxel fetch(uint3 id) {
    return unpackVoxelData(voxels[id]);
}

RWTexture3D<uint> vertexIds;

int size;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float3> colors;
RWStructuredBuffer<int> indices;

RWStructuredBuffer<uint> atomicCounters;

RWStructuredBuffer<UNITY_INDIRECT_DRAW_ARGS> cmdBuffer;

static uint3 edgePositions0[12] = {
    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
};

static uint3 edgePositions1[12] = {
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 0),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
    uint3(0, 0, 1),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 1, 1),
    uint3(0, 1, 1),
};

static uint3 test[3] = {
    uint3(1, 0, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 1),
};


static uint3 offsets[12] = {
    uint3(0, 0, 0),
    uint3(0, 1, 0),
    uint3(0, 1, 1),
    uint3(0, 0, 1),

    uint3(0, 0, 0),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 0, 0),

    uint3(0, 0, 0),
    uint3(1, 0, 0),
    uint3(1, 1, 0),
    uint3(0, 1, 0)
};

// https://www.ronja-tutorials.com/post/047-invlerp_remap/
float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

float3 normalMaxx(uint3 id) {
    float base = fetch(id).density;
    float x = fetch(id + uint3(1, 0, 0)).density;
    float y = fetch(id + uint3(0, 1, 0)).density;
    float z = fetch(id + uint3(0, 0, 1)).density;
    return normalize(float3(base-x, base-y, base-z));
}


[numthreads(4, 4, 4)]
void CSVertex(uint3 id : SV_DispatchThreadID) {
    if (any(id >= (uint)size)) {
        return;
    }

    int count = 0;
    float3 sum = float3(0, 0, 0);
    float3 normalSum = float3(0, 0, 0);

    for (int i = 0; i < 12; i++) {
        uint3 first = edgePositions0[i];
        uint3 second = edgePositions1[i];
        Voxel firstVoxel = fetch(id + first);
        Voxel secondVoxel = fetch(id + second);

        if (firstVoxel.density < 0.0 ^ secondVoxel.density < 0.0) {
            count++;

            float unlerped = invLerp(firstVoxel.density, secondVoxel.density, 0.0);
            sum += lerp(float3(first), float3(second), unlerped);
            normalSum += lerp(normalMaxx(id + first), normalMaxx(id + second), unlerped);
        }
    }

    if (count > 0) {
        uint oldValue = 0;
        InterlockedAdd(atomicCounters[0], 1, oldValue); 
        vertices[oldValue] = float3(id) + sum/float(count);
        normals[oldValue] = length(normalSum) < 0.1 ? 1.0 : normalize(-normalSum);
        colors[oldValue] = 1.0f;
        vertexIds[id] = oldValue;   
    }
}


[numthreads(8, 8, 8)]
void CSQuad(uint3 id : SV_DispatchThreadID) {
    if (any(id == (uint)(size-1)) || any(id <= 2)) {
        return;
    }

    for (int i = 0; i < 3; i++) {
        float firstDensity = fetch(id).density;
        float secondDensity = fetch(id + test[i]).density;
        bool flip = firstDensity < 0.0;

        if (firstDensity < 0.0 ^ secondDensity < 0.0) {
            int check[4] = { 0, 0, 0, 0 };

            bool valid = true;
            for (int j = 0; j < 4; j++) {
                check[j] = vertexIds[id + test[i] + offsets[j + i * 4] - 1];
            
                if (check[j] <= 0) {
                    valid = false;
                }
            }

            if (valid) {
                uint oldValue = 0;
                InterlockedAdd(atomicCounters[1], 6, oldValue); 
                
                indices[oldValue + (flip ? 0 : 2)] = check[0];
                indices[oldValue + 1] = check[1];
                indices[oldValue + (flip ? 2 : 0)] = check[2];
                
                indices[oldValue + (flip ? 4 : 3)] = check[2];
                indices[oldValue + 5] = check[3];
                indices[oldValue + (flip ? 3 : 4)] = check[0];
                
    
                InterlockedAdd(cmdBuffer[0].indexCountPerInstance, 6); 
            }
        }
    }
}