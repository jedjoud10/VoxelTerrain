#pragma kernel CSPropenator
#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Props/PropGeneratorStart.cginc"

Texture3D<float> _Voxels;
SamplerState sampler_Voxels;

Texture2D<float> _MinAxii;
SamplerState sampler_MinAxii;

float invLerp(float from, float to, float value) {
	return (value - from) / (to - from);
}

// Called for each voxel inside the prop segment to check if we should spawn a prop
// This will select the appropriate density prop and it will spawn it / render it
void CheckSpawnProps(uint3 id, float3 position) {
	// Mixer between biome 1 and biome 2
	float mixer = snoise(position.xz * 0.0003) * 0.5 + 0.5;
	mixer = smoothstep(0, 1, mixer - 0.2);
	float baseTest = _MinAxii[id.xy];

	if (position.y > -10.0 && position.y < 10 && (mixer < (hash13(position) * 0.07 - 0.05)) && baseTest > 0.0) {
		BlittableProp prop;

		float3 randomOffset = (2 * hash33(position) - 1) * float3(5, 0, 5);
		position += randomOffset;
		
		float randomScaleOffset = (2 * hash33(position) - 1) * 1;
		float3 randomRotation = (2 * hash33(position) - 1) * 180;

		baseTest *= propSegmentWorldSize / propSegmentResolution;
		baseTest += propChunkOffset.y;
		baseTest = (baseTest * worldScale.y) + worldOffset.y;

		/*
		float3 gridPos = position - worldOffset;
		gridPos /= worldScale;
		gridPos -= propChunkOffset;
		gridPos /= propSegmentWorldSize / propSegmentResolution;
		float3 normalizedGridPos = float3(gridPos.xzy / 64.0);
		 

		float baseTest = _MinAxii.SampleLevel(sampler_MinAxii, normalizedGridPos.xz, 0);
		float test = baseTest - worldOffset.y;
		test /= worldScale;
		test -= propChunkOffset.y;
		test /= propSegmentWorldSize / propSegmentResolution;
		float normalizedHeight = test / 64.0;

		float d1 = _Voxels.SampleLevel(sampler_Voxels, float3(normalizedGridPos.x, normalizedGridPos.y, normalizedHeight), 0);
		float d2 = _Voxels.SampleLevel(sampler_Voxels, float3(normalizedGridPos.x, normalizedGridPos.y, normalizedHeight + 1.0/64.0), 0);
		float l = invLerp(d1, d2, 0);
		float height = lerp(baseTest, baseTest + 8, l);
		*/

		position.y = baseTest;
		prop.position_and_scale = float4(position, 2.5 + randomScaleOffset * 0.0);
		prop.euler_angles_padding = float4(0, randomRotation.y, 0, 0) * 0.0;
		props.Append(prop);
	}
}

#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Props/PropGeneratorEnd.cginc"