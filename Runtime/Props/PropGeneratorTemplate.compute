#pragma kernel CSPropenator
#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Props/PropGeneratorStart.cginc"

Texture3D<float> _Voxels;
SamplerState sampler_Voxels;

Texture2D<float2> _MinAxii;
SamplerState sampler_MinAxii;

float3 WorldToPropSegment(float3 world) {
	// World offset and scale
	float3 gridPos = world - worldOffset;
	gridPos /= worldScale;

	// Inverse of PropSegmentToWorld
	gridPos -= propChunkOffset;
	gridPos /= propSegmentWorldSize / propSegmentResolution;
	gridPos /= 1.015625;
	return float3(gridPos.xzy / 64.0);
}

// Called for each voxel inside the prop segment to check if we should spawn a prop
// This will select the appropriate density prop and it will spawn it / render it
void CheckSpawnProps(uint3 id, float3 position) {
	// Mixer between biome 1 and biome 2
	float mixer = snoise(position.xz * 0.0003) * 0.5 + 0.5;
	mixer = smoothstep(0, 1, mixer - 0.2);
	//float2 baseTest = _MinAxii[id.xy];

	float3 randomOffset = (2 * hash33(position) - 1) * float3(10, 0, 10);
	float3 test3 = WorldToPropSegment(position + randomOffset);
	float2 baseTest = _MinAxii.SampleLevel(sampler_MinAxii, test3.xy, 0);
	float4 baseTest2 = _MinAxii.Gather(sampler_MinAxii, test3.xy, 0);

	// z direction
	float diff = -(baseTest2.x - baseTest2.z);

	// x direction
	float diff2 = -(baseTest2.x - baseTest2.y);
	float total = abs(diff) + abs(diff2);

	if (position.y > -10.0 && position.y < 10 && (mixer < (hash13(position) * 0.08 - 0.05)) && baseTest.y > 0.2 && total < 1.2) {
		BlittableProp prop;


		position += randomOffset;
		float randomScaleOffset = (2 * hash33(position) - 1) * 1;
		float3 randomRotation = (2 * hash33(position) - 1) * 180;

		position.y = baseTest.x;
		prop.position_and_scale = float4(position, 2.5 + randomScaleOffset * 0.7);
		prop.euler_angles_padding = float4(0, randomRotation.y, 0, 0);
		props.Append(prop);
	}
}

#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Props/PropGeneratorEnd.cginc"