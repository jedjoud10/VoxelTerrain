#pragma kernel CSVoxelizer

// Chunk offset + scale
float3 chunkOffset;
float chunkScale;

// World parameters
float3 worldOffset;
float3 worldScale;
float isosurfaceOffset;

// Seeding parameters
int3 permuationSeed;
int3 moduloSeed;

// Voxel resolution
int size;
float vertexScaling;
float voxelSize;

#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Utils/noises.cginc"
#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Utils/sdf.cginc"
#include "Packages/com.jedjoud.voxelterraingenerator/Runtime/Utils/morton.cginc"

// Used for async readback
RWTexture3D<uint> voxels;

float3 mod(float3 x, float3 y)
{
	return x - y * floor(x / y);
}

float de(float3 p) {
	float s = 3.0f, e;
	for (int i = 0; i++ < 3; ) {
		p = mod((p - 1.0f), 2.0f) - 1.0f;
		s *= e = 1.4f / dot(p, p);
		p *= e;
	}
	return length(p.yz) / s;
}

// Generates the voxel data on the GPU
[numthreads(4, 4, 4)]
void CSVoxelizer(uint3 id : SV_DispatchThreadID)
{
	// Calculate the main world position
	float3 position = float3(id.xzy);
	position -= 1.0;
	position *= voxelSize;

	// Chunk offsets + vertex scaling
	position *= vertexScaling;
	position *= chunkScale;
	//position += chunkOffset;
	position += (chunkOffset - ((chunkScale * size) / (size - 3.0)) * 0.5);
	
	// World offset and scale
	position = ((position * worldScale) / voxelSize) + worldOffset;

	// Density and material
	float biome = fbmCellular(position.xz * 0.003, 6, 0.32, 2.60).y * 150 - 20;
	float mask = saturate(sdSphere(position, 300) * 0.01);
	float density = position.y - lerp(biome, 0, 1-mask);
	uint packedMaterial = 0;

	// Morton encode the texture data
	uint packedDensity = f32tof16(density);
	uint packedData = packedDensity | (packedMaterial << 16);
	uint mortonIndex = encodeMorton32(id.xzy);
	uint3 mortonPos = indexToPos(mortonIndex);
	voxels[mortonPos.xzy] = packedData;
}