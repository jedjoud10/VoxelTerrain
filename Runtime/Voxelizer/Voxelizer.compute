#pragma kernel CSVoxelizer
#pragma kernel CSEdits

// Chunk offset + scale
float3 chunkOffset;
float chunkScale; 

// World parameters
float3 worldOffset;
float3 worldScale;
float isosurfaceOffset;

// Seeding parameters
int3 permuationSeed;
int3 moduloSeed;

// Voxel resolution
int size;
float vertexScaling;

// GPU representation of what a voxel is
// Density: first 2 bytes
// Material: 3rd byte
// Free: 4th byte

#include "./noises.cginc"
#include "./sdf.cginc"
#include "./morton.cginc"

// Used for async readback
RWTexture3D<uint> voxels;

// Generates the voxel data on the GPU
[numthreads(4,4,4)]
void CSVoxelizer (uint3 id : SV_DispatchThreadID)
{
    // Calculate the main world position
    float3 position = (float3(id.xzy) * chunkScale + chunkOffset);
    position *= vertexScaling;
    position *= worldScale;
    position += worldOffset;

    // Density value for biome 1
    float density1 = -fbmCellular(position * 0.002 * float3(1, 1.9, 1), 6, 0.49, 2.1).x * 100;
    density1 = opSmoothUnion(density1, position.y, 200);

    // Density value for biome 2
    float density2 = fbm(position.xz * 0.001, 8, 0.32, 2.61) * 320;
    density2 = opSmoothUnion(density2, position.y, 1600);
    density2 = -fbmCellular(position.xz * 0.001, 8, 0.32, 2.60).y * 600;

    // Density value for biome 3
    float density3 = abs(fbm(position * 0.001, 7, 0.4, 1.98)) * 100;

    // Mixer between biome 1 and biome 2
    float mixer = snoise(position.xz * 0.0006) * 0.5 + 0.5;
    mixer = smoothstep(0, 1, mixer);

    // Mixer between result and biome 3
    float mixer2 = snoise(position.xz * 0.0003 - 21.64) * 0.5 + 0.5;
    mixer2 = smoothstep(0, 1, mixer2);

    // Calculate density
    float density = lerp(lerp(density1, density2, mixer), density3, mixer2) + position.y;
    
    uint packedMaterial = 0;
    if (sdBox(position, float3(10, 10, 10)) < 0) {
        packedMaterial = 2;
    }

    //uint packedMaterial = 0;
    uint packedDensity = f32tof16(density);
    uint packedData = packedDensity | (packedMaterial << 16);

    // Morton encode the texture data
    uint mortonIndex = encodeMorton32(id.xzy);
    uint3 mortonPos = indexToPos(mortonIndex);
    voxels[mortonPos.xzy] = packedData;
}

[numthreads(4,4,4)]
void CSEdits (uint3 id : SV_DispatchThreadID)
{
    // Calculate the main world position
    float3 position = (id.xzy * chunkScale + chunkOffset) * worldScale + worldOffset;
}